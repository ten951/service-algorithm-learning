# service-algorithm-learning

## 26. 删除排序数组中的重复项

双指针解法. 

思路: 指针 p, q;

p代表不重复元素的开始位, q代表和p不重复元素的结束位. 

遍历目标数组. 直到p > nums.length

当 nums[p] != nums[q] 将p+1的位置赋值为 nums[q]; 
p++;
q++;

这样当循环结束时 p就是不重复元素最后一个. p+1就是不重复元素的个数;

在不相等的前提下: p代表不重复元素的开始位, q代表不重复元素的结束位. q-p是重复元素的个数. 如果q-p>1. 说明重复元素相距大于1. 需要移动. 否则相邻两个元素虽不相等. 但是紧挨着的不需要移动. 


## 11. 盛最多水的容器

双指针解法:

指针lo和指针hi. 分别指向数组头和尾. max记录最大的面试

面积的公式是高*宽.  hi-lo是宽. nums[lo]和nums[hi]是高. 由于可能不相等. 所以取两个值的min. 要装水嘛. 取max形成的桶水就流出来了.

当每次min(nums[lo], nums[hi])的时候, 相当于确定了高. 指针的移动是由nums[lo], nums[hi]大小控制的. 
nums[lo] < nums[hi] lo++; 也就是说找那个和hi相等的高可能在lo的右边. 否则, 和lo相等的高. 可能出现在hi的左边. 每次改变指针我们就会计算一次面积. 

取面积的最大值. 就是目标的

我的理解 nums[lo] 的 nums[hi]比较实在选取最优的高, lo和hi的改变是选取宽, 

## 283 移动零

双指针解法:

用指针j(默认值0)指向数组元素为0的位置. 指针i标记非零数组的位置. 

找到位置i 将值赋值非nums[j] 并且j++;

循环结束后 j的位置到nums.length, 就是非零数子的个数. 将其全部赋值为0

## 15 三数只和

## 189 旋转数组

思路1: 递归解法

先将数组原地反转. 然后反转0到k-1, 在旋转k-1到数组的长度-1;

## 206 反转链表

思路1 递归

1->2->3->4->5->NULL

1. 边界条件  尾节点, head == null || head.nex == null
2. 让4的下一个的下一个等于4.  4->5 就变成了5->4.  

思路2 遍历

有点快慢指针的意思. 
curr 当期节点
prev 指向curr的前一个节点

让curr前进. 
每次循环 
curr.next = prev;  这里会改变curr.next的值. 为了能够是curr前进. 需要临时变量temp保存curr.next
prev = curr;
curr = temp;

循环结束. prev 就是反转的

## 24 两两交换链表中的节点

思路1 快慢指针的方式

慢指针 1次一个节点
块指针 1次两个节点

1->2->3->4

添加辅助节点 -1 

-1->1->2->3->4
慢指针从1开始

块指针从2开始

1. -1 -> 2 -> 3 ->4
2. 1 -> 3 - > 4
3. -1 -> 2 -> 1 -> 3 -> 4
4. 慢指针从1前进到2



